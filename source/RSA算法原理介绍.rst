RSA算法
=======


基本原理介绍
----------
公钥与私钥的产生

假设A想要通过一个不可靠的媒体 **接收** B的一条私人消息。 她可以用以下的方式来产生一个公钥和一个私钥:

- 随意选择两个大的质数 ``p`` 和 ``q``,  ``p`` 不等于 ``q``, 计算 ``N = p * q``。
- 根据欧拉函数, 求得 ``r = f(N) = f(p) * f(q) = (p - 1) * (q - 1)``
- 选择一个小于 ``r`` 的整数 ``e``, 使 ``e`` 与 ``r```互质。 并求得 ``e`` 关于``r`` 的 **模反元素**, 命名为 ``d`` (求 ``d`` 令 ``e * d === 1 mod(r)``)。 (模反元素存在, 当且仅当 ``e`` 与 ``r`` 互质)
- 将 ``p`` 和 ``q`` 的记录销毁。
- ``(N, e)`` 是公钥,  ``(N, d)`` 是私钥。 A将她的公钥 ``(N, e)`` 传给B, 而将她的私钥 ``(N, d)`` 藏起来。


加密消息
-------
假设B想给A送一个消息 ``m``, 他知道A产生的 ``N`` 和 ``e``。 他使用起先与 ``Alice`` 约好的格式将 ``m`` 转换为一个小于 ``N`` 的整数 ``n``, 比如他可以将每一个字转换为这个字的Unicode码, 然后将这些数字连在一起组成一个数字。假如他的信息非常长的话, 他可以将这个信息分为几段, 然后将每一段转换为 ``n``。 用下面这个公式他可以将 ``n`` 加密为c::

	n ^ e === c mod(N)

计算 ``c`` 并不复杂。 B算出 ``c`` 后就可以将它传递给A。


解密消息
-------
A得到B的消息 ``c`` 后就可以利用她的密钥 ``d`` 来解码。 她可以用以下这个公式来将 ``c`` 转换为 ``n``::

	c ^ d === n mod(N)

得到 ``n`` 后, 她可以将原来的信息 ``m`` 重新复原。

解码的原理是::

	c ^ d === n ^ (e - d) mod (N)

以及 ``ed === 1 mod(p-1), ed === 1 mod(q-1)``。 由欧拉定理可证明(因为 ``p`` 和 ``q`` 是质数)::

	n ^ (e - d) === n mod(p) 和 n ^ (e - d) === n mod(q)

这说明(因为 ``p`` 和 ``q`` 是不同的质数, 所以 ``p`` 和 ``q`` 互质)::

	n ^ (e - d) === n mod(p*q)


签名消息
-------
RSA也可以用来为一个消息署名。假如A想给B传递一个署名的消息的话, 那么她可以为她的消息计算一个散列值(Message digest), 然后用她的私钥加密这个散列值并将这个“署名”加在消息的后面。 这个消息只有用她的公钥才能被解密。 B获得这个消息后可以用A的公钥解密这个散列值, 然后将这个数据与他自己为这个消息计算的散列值相比较。 假如两者相符的话, 那么他就可以知道发信人持有甲的密钥, 以及这个消息在传播路径上没有被篡改过。


Python实现: https://github.com/MacHu-GWU/cryptology-in-python/blob/master/lsn03_rsa.py